require 'optparse'
require "vagrant"

module VagrantPlugins
  module VagrantFlow
    class Command < Vagrant.plugin("2", :command)
      
      # Builtin from Command class
      # Must override to provide a description
      def self.synopsis
        "generates a ansible inventory file from the vagrant environment"
      end

      
      # Builtin from Command class
      # Must override to provide core functionality
      def execute
        
        machines_configs = {}
        inventory_configs = {}
        
        options = {}
        options[:destroy_on_error] = true
        options[:parallel] = false
        options[:provision_ignore_sentinel] = false

        opts = OptionParser.new do |o|
          # o.banner = "Usage: vagrant ansible-inventory [vm-name] [options] [-h]"
          o.banner = "Usage: vagrant ansible-inventory [-h]"
          o.separator ""

          # Don't use either of these, just keeping them here as examples of what options are possible 
          o.on("--provision-with x,y,z", Array,
                  "Enable only certain provisioners, by type.") do |list|
            options[:provision_types] = list.map { |type| type.to_sym }
          end
          
          # This option isn't used.
          o.on("--[no-]parallel",
               "Enable or disable parallelism if provider supports it.") do |parallel|
            options[:parallel] = parallel
          end

        end

        # Parse the options # Builtin from the Command Class
        # Will safely parse the arguments and 
        # Automatically detects -h for help
        argv = parse_options(opts)
        return if !argv

        # The following are already setup by the parent class
        # @env
        # @logger
        # @argv

        # Go over each VM and bring it up
        @logger.debug("'ansible-inventory' created for the whole env")

        # Example from the up command
        
        # Build up the batch job of what we'll do
        # @env.batch(options[:parallel]) do |batch|
        #   with_target_vms(argv, :provider => options[:provider]) do |machine|
        #     @env.ui.info(I18n.t(
        #       "vagrant.commands.up.upping",
        #       :name => machine.name,
        #       :provider => machine.provider_name))
        # 
        #     batch.action(machine, :up, options)
        #   end
        # end
        
        
        
        with_target_vms(argv, :provider => options[:provider]) do |machine|
          # @env.ui
          # output methods: :ask, :detail, :warn, :error, :info, :output, :success
          # https://github.com/mitchellh/vagrant/blob/master/lib/vagrant/ui.rb
          
          ssh_info = machine.ssh_info
          raise Vagrant::Errors::SSHNotReady if ssh_info.nil?

          variables = {
            :host_key => options[:host] || machine.name || "vagrant",
            :ssh_host => ssh_info[:host],
            :ssh_port => ssh_info[:port],
            :ssh_user => ssh_info[:username],
            :private_key_path => ssh_info[:private_key_path],
            :forward_agent => ssh_info[:forward_agent],
            :forward_x11   => ssh_info[:forward_x11]
          }
          
          # Outputs to the stdout
          # @env.ui.info(machine.name)
          
          # From - Vagrant::Util::SafePuts
          # Template is erb
          
          # Implementation picks the first key
          # ssh_info[:private_key_path] returns an array
          
          inventory_configs = {
            :vagrant_file_dir => machine.env.root_path,
            :vagrant_flow_file => machine.env.root_path.join("vagrant-flow_ansible_inventory")
          }
          
          machines_configs[variables[:host_key]]= variables
          
          # ansible_template = '<%= host_key %> ansible_ssh_host=<%= ssh_host %> ansible_ssh_port=<%= ssh_port %> ansible_ssh_user=<%= ssh_user %> ansible_ssh_private_key_file=<%= private_key_path[0] %> # Machine Name: <%= host_key %>'
          # safe_puts(Vagrant::Util::TemplateRenderer.render_string(ansible_template, variables))

        end
        
        inventory_configs[:vagrant_flow_file].open('w') do |file|
          header_txt="# Generated by vagrant-flow, part of NeverwinterDP\n\n"
          safe_puts(header_txt)
          file.write(header_txt)
          machines_configs.each do |host, variables|
            ansible_template = '<%= host_key %> ansible_ssh_host=<%= ssh_host %> ansible_ssh_port=<%= ssh_port %> ansible_ssh_user=<%= ssh_user %> ansible_ssh_private_key_file=<%= private_key_path[0] %> # Machine Name: <%= host_key %>'
            host_txt=Vagrant::Util::TemplateRenderer.render_string(ansible_template, variables)
            safe_puts(host_txt)
            file.write("#{host_txt}\n")
          end
        end
        
        # Test writing the the path variables out.
        # safe_puts("vagrant_file_dir: #{inventory_configs[:vagrant_file_dir]}")
        # safe_puts("vagrant_flow_file: #{inventory_configs[:vagrant_flow_file]}")
        
        
        
        # Give it machine from with_target_vms
        # def setup_inventory_file(machine)
        #   return config.inventory_path if config.inventory_path
        # 
        #   ssh = machine.ssh_info
        # 
        #   generated_inventory_file =
        #     machine.env.root_path.join("vagrant_ansible_inventory_#{machine.name}")
        # 
        #   generated_inventory_file.open('w') do |file|
        #     file.write("# Generated by Vagrant\n\n")
        #     file.write("#{machine.name} ansible_ssh_host=#{ssh[:host]} ansible_ssh_port=#{ssh[:port]}\n")
        # 
        #     # Write out groups information.  Only include current
        #     # machine and its groups to avoid Ansible errors on
        #     # provisioning.
        #     groups_of_groups = {}
        #     included_groups = []
        # 
        #     config.groups.each_pair do |gname, gmembers|
        #       if gname.end_with?(":children")
        #         groups_of_groups[gname] = gmembers
        #       elsif gmembers.include?("#{machine.name}")
        #         included_groups << gname
        #         file.write("\n[#{gname}]\n")
        #         file.write("#{machine.name}\n")
        #       end
        #     end
        # 
        #     groups_of_groups.each_pair do |gname, gmembers|
        #       unless (included_groups & gmembers).empty?
        #         file.write("\n[#{gname}]\n")
        #         gmembers.each do |gm|
        #           file.write("#{gm}\n") if included_groups.include?(gm)
        #         end
        #       end
        #     end
        #   end
        # 
        #   return generated_inventory_file.to_s
        # end
        
        # Documentation Ahead is from:
        # http://docs.ansible.com/intro_inventory.html
        
        # ansible_ssh_host
        #   The name of the host to connect to, if different from the alias you wish to give to it.
        # ansible_ssh_port
        #   The ssh port number, if not 22
        # ansible_ssh_user
        #   The default ssh user name to use.
        # ansible_ssh_pass
        #   The ssh password to use (this is insecure, we strongly recommend using --ask-pass or SSH keys)
        # ansible_sudo_pass
        #   The sudo password to use (this is insecure, we strongly recommend using --ask-sudo-pass)
        # ansible_connection
        #   Connection type of the host. Candidates are local, ssh or paramiko.  The default is paramiko before Ansible 1.2, and 'smart' afterwards which detects whether usage of 'ssh' would be feasible based on whether ControlPersist is supported.
        # ansible_ssh_private_key_file
        #   Private key file used by ssh.  Useful if using multiple keys and you don't want to use SSH agent.
        # ansible_python_interpreter
        #   The target host python path. This is useful for systems with more
        #   than one Python or not located at "/usr/bin/python" such as \*BSD, or where /usr/bin/python
        #   is not a 2.X series Python.  We do not use the "/usr/bin/env" mechanism as that requires the remote user's
        #   path to be set right and also assumes the "python" executable is named python, where the executable might
        #   be named something like "python26".
        # ansible\_\*\_interpreter
        #   Works for anything such as ruby or perl and works just like ansible_python_interpreter.
        #   This replaces shebang of modules which will run on that host.
        
        
        # Success, exit status 0
        
        
        
        0
      end # End Execute
      
      
      def setup_inventory_file(machine)
        return machine.config.inventory_path if machine.config.inventory_path

        ssh = machine.ssh_info

        generated_inventory_file =
          machine.env.root_path.join("vagrant-flow_ansible_inventory")

        generated_inventory_file.open('w') do |file|
          file.write("# Generated by Vagrant\n\n")
          file.write("#{machine.name} ansible_ssh_host=#{ssh[:host]} ansible_ssh_port=#{ssh[:port]}\n")

          # Write out groups information.  Only include current
          # machine and its groups to avoid Ansible errors on
          # provisioning.
          groups_of_groups = {}
          included_groups = []

          config.groups.each_pair do |gname, gmembers|
            if gname.end_with?(":children")
              groups_of_groups[gname] = gmembers
            elsif gmembers.include?("#{machine.name}")
              included_groups << gname
              file.write("\n[#{gname}]\n")
              file.write("#{machine.name}\n")
            end
          end

          groups_of_groups.each_pair do |gname, gmembers|
            unless (included_groups & gmembers).empty?
              file.write("\n[#{gname}]\n")
              gmembers.each do |gm|
                file.write("#{gm}\n") if included_groups.include?(gm)
              end
            end
          end
        end

        return generated_inventory_file.to_s
      end
      
    end
  end
end
